# Service

> 백그라운드 작업을 위한 애플리케이션 구성 요소



화면 없이 백그라운드에서 실행되는 프로세스를 의미한다.

액티비티처럼 하나의 애플리케이션 구성 요소로 동작한다.



서비스도 애플리케이션의 구성 요소이므로 시스템에서 관리한다.

따라서 새로 만든 서비스는 항상 매니페스트 파일에 등록해야 한다.

서비스를 실행 시킬 때는 메인 액티비티에서 `startService()` 메소드를 호출하면 된다.



서비스가 하는 중요한 역할은 단말이 항상 실행되어 있는 상태로 다른 단말과 데이터를 주고받거나 단말의 상태를 모니터링하는 것이다.

따라서 서비스를 한 번 실행해 두면 실행된 상태가 계속 유지되어야 한다.

이를 위해 서비스가 비정상적으로 종료되덛라도 시스템이 자동으로 재실행된다.



그런데 서비스가 한 번 실행된 후 종료되지 않고 계속 실행 중인 상태라면 `startService()` 메소드 여러 번 호출하더라도 서비스의 상태에는 변화가 없게된다. 따라서 `startService()` 는 서비스를 시작하는 목적보다는 인텐트를 전달하는 목적으로 더 많이 사용된다.



예를 들어, 액티비티에서 서비스 쪽으로 데이터를 전달하고 싶은 경우 인텐트 객체를 만들고 부가 데이터를 넣은 후 `startService()` 메소드를 호출하면서 전달하면 된다.

이 때 서비스 객체가 메모리에 만들어져 있으면 `onCreate()` 메소드가 호출되지 않으므로 `onStartCommon()` 메소드를 사용해 전달 받은 인텐트를 처리 하게 된다.



## 서비스의 3가지 유형

### 백그라운드

> 사용자에게 직접 보이지 않는 작업을 수행

백그라운드는 이름 그대로 사용자에게 직접 보이지 않는 작업을 수행한다.

액티비티가 사용자에게 직접 보이는 화면이라면

서비스는 뒤에서 필요한 작업을 수행한다.

애플리케이션이 꺼도 백그라운드 서비스는 계속 수행 할 수 있다.



### 바인더

> 바인딩을 위한 서비스

바인딩을 위한 서비스이다.

여러 구성 요소를 서비스에 바인딩하여 서비스와 상호작용할 수 있다.

클라이언트- 서버 유형과 비슷하다고 생각할 수 있다.

액티비티와 서비스는 따로 운영될 수 있지만

서볼 바인딩하여 통신할 수도 있다.

`bindService()` 를 호출하여 사용한다.

바인딩이 해제되면 해당 서비스는 소멸된다.



### 포그라운드

> 사용자에게 직접 보이는 작업을 수행

서비스는 포그라운드로도 실행할 수 있다.

이름 그래도 사용자에게 직접 보이는 작업을 수행한다.

예를 들어 오디오 앱에서 트랙을 재생할 때 포그라운드 서비스를 사용한다.

포그라운드인데 왜 서비스인것이냐?

​	-> 사용자가 다른 앱을 사용중이어도 계쏙해서 실행되도록 하기 때문이다.



## 서비스 콜백 메소드



서비스를 생성하려면 `Service` 의 서브클래스를 생성해야 한다.

구현에서는 서비스 수명 주기의 주요 측면을 처리하는 콜백 메서드를 몇 가지 재정의해야 하며 서비스에 바인드할 구성 요소에 대한 메커니즘을 제공해야 한다.



- `onStartCommand()`

  서비스를 시작하도록 요청하는 메소드이다.

  서비스를 실행하려는 곳(ex- Activity)에서 `startService()` 를 써서 호출된다.

  이 메소드가 실행되면 서비스가 시작되고 백그라운드에서 무한히 실행될 수 있다.

  서비스를 중단하는 것은 `stopSelf()` 또는 `stopService()` 를 써서 호출하면 된다.

  바인딩만 제공하고자 하는 경우에는 `onStartCommand()` 를 구현하지 않아도 된다.

- `onBind()`

  다른 구성 요서와 서비스를 바인딩하려는 경우에 호출한다.

  바인딩을 실행하려는 곳(ex - Activity)에서 `bindService()` 를 써서 호출된다.

  구현을 할 때는 interface를 제공해야 한다.

  return으로 IBinder를 반환하면 된다.

  이 메소드는 항상 구현해야 한다.

  구현을 하는 데 바인딩을 하지 않으면 return값으로 null을 반환하면 된다.

- `onCreate()`

  `onStartCommand()` 또는 `onBind()` 를 호출하기 전에 호출한다.

  `onStartCommand()` 또는 `onBind()` 에서 서비스를 실행하거나 바인딩을 하고 나면 서비스가 계속해서 실행되고 있는 중이 되기 때문에 일회성으로 실행되며, 서비스가 이미 실행 중이면 `onCreate()` 는 호출되지 않는다.

- `onDestory()`

  서비스를 소멸시킬 때 호출한다.

  각종 리소스를 정리하기 위해 구현해야 한다.



## 서비스 호출과 소멸



### 1. `startService()` 서비스 호출

한 구성 요소 (ex - Activity)에서 `startService()` 를 써서 서비스를 호출하면 `onStartCommand()` 가 호출되고 서비스가 중단되기 전까지는 서비스를 실행중인 상태로 유지한다.



서비스를 중단하는 방법은 `stopSelf()` 로 스스로 중단하거나 다른 구성 요성에서 `stopService()` 를 써서 호출할 수 있다.



### 2. `bindService()` 바인딩 호출

한 구성 요소에서 `bindService()` 를 써서 서비스를 호출하면 해당 서비스는 해당 구성 요소가 바인딩된 경우에만 실행된다.

서비스가 모든 바인딩이 해제되면 시스템에 의해 소멸된다.



### 3.서비스 소멸

안드로이드 시스템이 서비스를 강제로 소멸하는 경우는,

메모리 부족으로 인해 리소스를 정리하는 경우에 국한된다.



서비스가 강제로 소멸할 가능성

- 서비스가 포그라운드에서 실행되는 경우 -> 소멸 가능성 희박
- 서비스가 바인딩된 경우 -> 소멸 가능성 희박
- 서비스가 백그라운드에서 장시간 실행 중 -> 소멸 가능성 높음



### 4. 서비스 소멸 후 재시작

서비스가 시스템에 의해 소멸된 경우, 서비스가 다시 시작할 여부는 `onStartCommand()`의 return값에 따라 달라질 수 있다.

`onStartCommand()` 는 3가지 반환 값을 가질 수 있다.



- START_REDELIVER_INTENT

  시스템이 서비스를 중단하면 서비스를 다시 생성한다.

  그리고 이 서비스에 전달된 마지막 인텐트로 `onStartCommand()` 를 호출한다.

  모든 보류 인텐트가 차례로 전달된다.

  파일 다운로드와 같은 서비스에 적합

- START_STICKY

  시스템이 서비스를 중단하면 서비스를 다시 생성한다.

  마지막 인텐트로 전달하지 않고 null 인텐트로 `onStartCommand()` 를 호출한다.

  명령을 실행하지 않지만 작업을 기다리는 미디어 플레이어와 같은 서비스에 적합하다.

- START_NOT_STICKY

  시스템이 서비스를 중단하면 서비스를 재성성하지 않는다.

  다시 시작하려는 경우에 적합하다.



## 서비스 클래스

```kotlin
class MyService : Service() {
  
  // 서비스 최초 생성될 때만 호출
  override fun onCreate() {
    
  }
  
  // startService()로 서비스를 시작할 때 호출
  override fun onStartCommand(intent : Intent, flags : Int, startId : Int) : Int {
    return START_STICKY
  }
  
  // bindService()로 바인딩을 실행할 때 호출
  override fun onBind(intent : Intent) : IBinder {
    return mBinder
  }
  
  // unbindService() 로 바인딩을 해제할 때 호출
  override fun onUnbind(intent : Intent) : Boolean {
    return mAllowRebind
  }
  
  // 이미 onUnbind()가 호출된 후에 bindService()로 바인딩을 실행할 때 호출
  override fun onRebind(intent : Intent){
    
  }
  
  //서비스가 소멸될 때 호출
  override fun onDestroy(){
    
  }
}
```



## 서비스 생명주기



서비스 생명 주기는 두 가지로 나뉜다.

- `startService()` 로 서비스를 실행
- `bindService()` 로 바인딩만 제공하는 경우

 ![img](https://blog.kakaocdn.net/dn/csvOQo/btqEmwgjKcm/GZLLDKs46ed0aVF09wGFv1/img.png)



## 서비스 시작과 중단



### 1. 서비스 시작

서비스는 다른 구성 요소에서 `startService()` 를 써서 서비스의 `onStartCommand()` 를 호출하면서 시작된다.

호출할 때는 Intent를 전달하는데, 예를 들어 다음과 같이 호출할 수 있다.

```kotlin
startService(Intent(context,Service::class.java))
```



이 호출을 서비스의 `onStartCommand()` 에서 받는다.

서비스가 시작되면 이를 호출한 구성 요소와 독립적인 수명 주기를 가진다.

즉 서비스는 백그라운드에서 무한히 실행될 수 있고, 서비스를 호출한 구성 요소가 소멸되어도 계속 실행될 수 있다.



### 2. 서비스 중단

서비스는 수명주기를 직접 관리해야 한다.

즉, 시스템은 기본적으로는 서비스를 중단이나 소멸시키지 않는다.

`stopSelf()` 로 스스로 중지하거나, 다른 구성 요소에서 `stopService()` 를 써서 소멸시킬 수 있다.

```kotlin
stopService(Intent(context,Service::class.java))
```



### 3. 액티비티 내에서만 실행 및 중단

서비스를 액티비티가 실행 중인 동안에만 작동하도록 하려면 액티비티의 `onCreate()` 에서 서비스를 생성하고 `onStart()` 에서 서비스를 실행하고 `onStop()` 에서 서비스를 중단하면 된다.



## 바인딩 서비스 생성

바인딩된 서비스는 `bindService()` 를 호출하여 다른 구성 요소를 서비스에 바인딩할 수 있다.

바인딩된 서비스를 생성하려면 `onBind()` 콜백 메소드를 구현하여 서비스와의 통신을 위한 Interface를 정의하는 `Ibinder` 를 return 해야 한다.

그렇게 하면 다른 구성 요소가 `bindService()` 를 호출하여 해당 Interface를 검색하고 서비스에 있는 메소드를 호출 할 수 있다.



서비스는 바인딩된 구성 요소를 돕기 위해 존재하는 것이기 때문에 구성 요소가 솜려되면 시스템이 서비스도 소멸 시킨다.

그래서 바인딩된 서비스는 기본적으로 직접 중단하지 않아도 된다.



여러 구성 요소가 한 서비스에 바인딩 될 수 있다.

구성 요소는 `unbindService()` 를 호출하여 서비스에 바인딩을 해제할 수 있고 서비스에 바인딩된 구성 요소가 하나도 남지 않게 되면 서비스가 서비스를 소멸시킨다.





----

참고 사이트

티스토리 : https://jhshjs.tistory.com/48

공홈 : https://developer.android.com/guide/components/services?hl=ko