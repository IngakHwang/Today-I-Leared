# 삼미자전거 라이브러리 흐름

> 블루투스 스캔, 연결 중심으로 라이브러리 흐름 파악



Starting point

MainActivity.java - btnConnect.setOnClickListener

​	DeviceName의 EditText 값을 인자로 mbiModule(SammiMbiModule 객체)의 connect 함수 실행

mbiModlule.connect(inputDeviceName)



**SammiMbiModule.java**

## Connect(String deviceName)

> Line 130
>
> 블루투스 기존 연결 체크 및 블루투스 스캔, 초기화 작업 실시

1. 인자로 받아온 deviceName을 qr_device_name 이라는 변수에 할당

2. localTask가 null 이고 

   블루투스 기능이 켜져 있고 (bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON)

   ​	GATT가 null이 라면 기존 GATT 연결해제

   

   블루투스 초기화 작업 **bluetooth_initialize()**

   블루투스 스캔작업 실시 **scanLeDeivce(true)**

   localTask에 **BluetoothTask()** 객체 할당 및 execute() 메소드 실행



### bluetooth_initialize()

> Line 436
>
> 블루투스 실행을 위한 초기화



아래 3개 메소드 실행

bluetoothSupportCheck() : 블루투스 지원하는 장비인지 체크하는 메소드

bluetoothEnalbeCheck() : 블루투스 기능이 켜져 있는지 체크하는 메소드

bluetoothPermissionCheck() : 블루투스 퍼미션을 가지고 있는지 체크하는 메소드



**블루투스 실행을 위한 초기화**

----

mGattServices.clear (ArrayList<BluetoothGattService>) : ArrayList 아이템 비우기

mConnectionState = STATE_SCANNING 으로 바꾸기 (Int)

mBluetoothErrorCode = ERROR_CODE_NO_ERROR 로 바꾸기 (Int)

mWritealbeCharacteristics.clear() (ArrayList<BluetoothGattCharacteristic>)

mGattCharaceteristics.clear() (ArrayList<BluetoothGattCharacteristic>)

notification_string, notification_display = null로 초기화

mBluetoothGatt가 null 이 아니라면 null로 만들기

-----



### scanLeDeivce (boolean enable)

> Line 454
>
> scanLeDevice 인데 오타로 추정
>
> 입력 boolean에 따라 블루투스 스캐닝 동작 제어

true 일 때

mbiDataListner.onBleStatusChanged(BleStatus.SCANNING) : BLE스캐닝 상태를 SCANNING으로 변경 (BleStatus는 Enum 클래스)

BluetoothLeScanner.startScan(**mScanCallback**) : BLE 스캔 시작 (인자로 받는 mScanCallback은 abstract로 구현해야하는 클래스)



false 일 때

mbiDataListner.onBleStatusChanged(BleStatus.STOP_CANNING) : BLE스캐닝 상태를 정지로 변경

BluetoothLeScanner.stopScan(mScanCallback) : BLE 스캔 정지



#### ScanCallBack() - abstract class

> Line 464
>
> 스캔에 따른 콜백 명령 수행
>
> 스캔 후 단말기 연결



onScanResult(int callbackType, ScanResult result) : mbiDataListener.onScanResultReceived(ScanResult) 리스너에 값 전달 및 **processResult(ScanResult) 메소드 실행**

onBatchScanResults(List<ScanResult> results) : results item을 하나씩 꺼내는 for문 사용하여 **processResult(result) 메소드** 실행

onScanFailed(int errorCode) : mbiDataListner.onBleStatusChanged(BleStatus.SCAN_FAIL (ENUM)) 전달



@Override

---

onScanResult(int callbackType, ScanResult result) : BLE 발견되면 콜백

onScanFailed(int errorCode) : 스캔을 시작할 수 없을 때 콜백

onBatchScanResults(List<ScanResult> results) : 일괄처리결과가 전달될 때 콜백

---



**processResult(final ScanResult result)**

> Line 485
>
> 블루투스 스캔 중일 때 단말기 연결

입력값 result.getDevice() 사용하여 BluetoothDevice 객체 device 할당

result.getScanRecord().getDeviceName() 으로 String deviceName 할당



qr_device_name과 deviceName null 체크 + 길이가 5미만인지 체크



mConnectionState 가 STATE_SCANNING 일 때만 (블루투스 스캔 중일 때만 단말기 연결 시도)

qr_device_namer과 deviceName의 값 뒤에 5자리로 매칭되는 기기 검색

​	두값의 뒤에 5자리가 동일하다면 Device Found

​	위에 할당된 device를 클래스에 미리 선언해두었던 mDevice에 할당

​	mConnectionState 를 STATE_CONNECTING으로 변경

​	mbiDataListener.onBleStatusChanged(BleStatus.CONNECTING)

​	scanLeDeivce(false) : 스캔중지

​	쓰레드 0.1초 sleep 후

​	**connectToDevice(mDvice)**



##### connectToDevice(BluetoothDevice device)

> Line 530
>
> 단말기 연결

BluetoothGatt가 null 이고

빌드 버전이 23 이상이면

​	BluetoothGatt 객체 device.connectGatt(ctx, false, **mGattCallback**, BluetoothDevice.TRANSPORT_LE)

빌드 버전 23 미만이면

​	BluetoothGatt 객체 device.connectGatt(ctx, false, **mGattCallback**)

---

connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport) : 이 장치에서 호스팅하는 GATT 서버에 연결

----





###### BluetoothGattCallback() - abstract class

> Line 543
>
> BluetoothGattCallback 구현



onConnectionStateChange(gatt, status, newState) : 

> newState 값에 따른 GATT server connect

​	newState switch

​		BluetoothProfile.STATE_DISCONNECTED 이면

​			mConnectionState = STATE_DISCONNECTED

​			mbiDataListener.onBleStatusChanged(BleStatus.DISCONNECTED)

​		BluetoothProfile.STATE_CONNECTED 이면

​			mBluetoothGatt.discoverServices() : 서버 연결 시도

​			mConnectionState = STATE_CONNECTED

​			mbiDataListener.onBleStatusChanged(BleStatus.CONNECTED)



onServicesDiscovered(BluetoothGatt gatt, int status) : 

> Status 값에 따른 Discovery Service Start

​	status 값이 BluetoothGatt.GATT_SUCCESS 면

​		**checkGattServices(BletoothGatt.getServices()) 메소드 실행**



onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) : 

> status 값이 BluetoothGatt.GATT_SUCCESS 면 로그 실행



onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) : 

> characteristic의 문자열화 하여 "L_CL_OK" 포함여부 확인

​	characteristic.getStringValue하여 notification_string에 담기

​	notification_string에 "L_CL_OK"가 포함되어 있으면

​	mbiDataListener.onBikeStatusChanged(BikeStatus.CLOSED)



---

onConnectionStateChange(BluetoothGatt gatt, int status, int newState) : GATT 클라이언트가 원격 GATT 서버에 연결/연결 해제되었을 때를 나타내는 콜백

onServicesDiscovered(BluetoothGatt gatt, int status) : 원격 장치에 대한 원격 서비스, 특성 및 설명자의 목록이 업데이트되었을 때, 즉 새로운 서비스가 발견되었을 때 호출되는 콜백

onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) : 특성 읽기 작업의 결과를 보고하는 콜백

onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) : 원격 특성 알림의 결과로 트리거된 콜백

----

###### # checkGattServices(List<BluetoothGattService> gattServices)

> Line 598
>
> GattService에서 온 데이터 확인?
>
> GattService 연결확인?



BluetoothAdapter, BluetoothGatt null check

for(BluetoothGattService gattService : gattServices) -> gattServices item 갯수만큼 for문

​	mGattServices.add(gatterService) : <BluetoothGattService> ArrayList item add

​	gattService.getCharacteristics()로 서비스에 포함된 특성 목록 반환하여 List<BluetoothGattCharacteristic> gattCharacteristics에 할당

​	

​	for() -> gattCharacteristics item 갯수만큼 for문

​		mGattCharacteristics.add(gattCharacteristic) : <BluetoothGattCharacteristic> ArrayList item add

​		gattCharacteristic의 uuid가 selected_data_uuid와 같다면

​			**isWritableCharacteristic(gattCharacteristic) 메소드** 실행 (반환값 boolean)

​				true이면 mWritableCharacteristics.add(gattCharacteristic)

​				

​			**isReadableCharacteristic(gattCharacteristic) 메소드** 실행 (반환값 boolean)

​				true이면 **readCharacteristic(gattCharacteristic) 메소드** 실행

​			

​			**isNotificationCharacteristic(gattCharacteristic) 메소드** 실행 (반환값 boolean)

​				true이면 **setCharacteristicNotification(gattCharacteristic, true) 메소드** 실행

​			mConnectionState = STATE_SERVICE_FOUND

​			mbiDataListener.onBleStatusChanged(BleStatus.SERVICE_FOUND)

​			break

​			두번째 for문 종료

​		mConnectionState == STATE_SERVICE_FOUND 면 break

​		첫번째 for문 종료

mConnectionState != STATE_SERVICE_FOUND 면

​	mConnectionState == STATE_SERVICE_NOT_FOUND

​	mbiDataListener.onBleStatusChanged(BleStatus.NP_SERVICE)



###### ## isWritableCharacteristic(BluetoothGattCharacteristic chr) : boolean

> chr.getProperties를 받아와서 chr.getProperties 값과
>
> BluetoothGattCharacteristic.PROPERTY_WRITE | 
>
> BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE가 0보다 크면
>
> true return 아니면 false



###### ## isReadableCharacteristic(BluetoothGattCharacteristic chr) : boolean

> chr.getProperties를 받아와서 chr.getProperties 값과
>
> BluetoothGattCharacteristic.PROPERTY_READ가 0보다 크면
>
> true return 아니면 false



###### ## readCharacteristic(BluetoothGattCharacteristic characteristic)

> BluetoothAdapter, BluetoothGatt null check 후
>
> BluetoothGatt.readCharcteristic(characteristic) 실행

연결된 원격 장치에서 지정된 설명자의 값을 읽는다.



###### ## isNotificationCharacteristic(BluetoothGattCharacteristic chr) : boolean

> chr.getProperties를 받아와서 chr.getProperties 값과
>
> BluetoothGattCharacteristic.PROPERTY_NOTIFY가 0보다 크면
>
> true return 아니면 false



###### ## setCharacteristicNotification(BluetoothGattCharacteristic characteristic, boolean enabled)

> BluetoothAdapter, BluetoothGatt null check 후
>
> 

*추가로 해야 함*



### BluetoothTask() - class

> Line 188
>
> AsyncTask<Void, String, Void> 를 상속 (Background 작업 및 UI 변경 작업 구현?)
>
> Bluetooth 연결 관련한 Class



doInBacground(Void... voids) : 안드로이드와 단말기 블루투스 연결

​	단말기 ID가 존재하는 지 검사

​	단말기와 연결되었는지 검사

​	단말기와 연결된 경우 암호키 전송 : bluetooth_data_send(String str)



​	모르겠는 것 : publishProgress()



onPostExecute(Void result) : 응답 내용 확인

​	에러코드가 ERROR_CODE_NO_ERROR 이고

​	notification_string이 null 아니라면

​	notification_string 문자열 확인하여 mbiDataListener.onBikeStatusChanged(BikeStatus.ENUM) 실행



​	에러코드가 ERROR 관련 코드 라면

​	mbiDataListner.onBleStatusChanged(BleStatus.ENUM) 실행





@Override

----

onPreExecute() : 백그라운드 작업을 수행하기 전 호출되며 에인 스레드에서 실행되고 초기화작업에 사용 (이 클래스에선 사용X)

onCancelled() : AsyncTask 객체를 cancel() 로 종료시키면 호출되는 메소드 (사용 X)

doInBackground(Void... voids) : 새로 만들어진 스레드, 즉 백그라운드 작업을 할 수 있다.

그리고 excute() 메소드를 호출할 때 사용된 파라미터를 배열로 전달받을 수 있다.

중간중간마다 UI 객체에 접근할려면 메인스레드에서 해야하므로 publishProgress() 를 호출해 nProgressUpdate()를 불러와서 메인스레드에서 UI 작업이 가능해진다.



onPostExecute(Void result) : AsyncTask의 모든 작업이 완료된 후 가장 마지막에 한 번 호출, doInBackground() 함수의 최종 값을 받기 위해 사용



onProgressUpdate() : doInBackground() 함수에 의해 처리되는 중간중간 값을 받아 처리 하기 위해 호출. doInBackground() 함수에서 publishProgress() 함수로 넘긴 값이 전달

---

#### bluetooth_data_send(String str) : boolean

> Line 715
>
> BluetoothGatt 를 가지고 무언가를 한다
>
> 무엇을 할까? -> 데이터를 보낸다? (어떤 데이터를? 어디로?)

BluetoothGattService 객체를 BluetoothGatt 객체의 getService(UUID.fromString(uuid)) 메소드 사용해서 선언



BluetoothGattCharacteristic 객체를 GattService 객체의 getCharacteristic(UUID.fromString(uuid)) 메소드 사용해 선언



GattCharacteristic.setValue 메소드에 입력받은 str 입력

setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE) 사용



BluetoothGatt.writeCharacteristic(GattCharacteristic)의 값이 true면 true return

아니면 false return

