# JVM

> 자바 기반 어플리케이션을 클래스 로더를 통해 읽어들이고, 자바 API와 함께 실행하는 역할

Java Virtual Machine



JVM 역할

- JVM 기반 프로그램이 플랫폼, 운영체제에 국한되지 않고 실행될 수 있도록 해준다.

- JVM 기반 프로그램의 메모리를 관리하고 최적화해준다.



JVM 은 자바 기반 어플리케이션을 클래스 로더를 통해 읽어들이고, 자바 API와 함께 실행하는 역할

Java 프로그램과 OS 중간에 껴 중개자 역할을 함으로써 기기 및 OS의 제한없이 프로그램의 재사용성을 증대시킨다.



## JVM 기본 구성

JVM 기반 프로그램이 실행되는 과정을 살펴보기 전에, 먼저 JVM 을 구성하는 요소들 가각에 대해 알아보자.

![img](https://media.vlpt.us/images/haero_kim/post/84b5e967-a182-4325-b1be-32e7ed1d2abf/Vy1JC1b.png)

### 자바 컴파일러 (javac)

자바 소스코드 (`.java`)를 바이트 코드(`.class`)로 변환, 컴파일해주는 역할을 수행한다.



### 클래스 로더

> 바이트 코드를 로드하고 메모리 영역(Runtime Data Areas)에 배치시키는 역할

프로그래머가 자바로 프로그램을 짜면 결과물은 `.java` 파일이 되고,

그 파일은 컴파일러 에 의해 `.class` 바이트 코드로 컴파일된다.

JVM은 런타임 시에 최초로 바이트 코드를 참조할 때, 해당 바이트 코드를 로드하고 메모리 영역 (Runtime Data Areas) 에 배치시킨다.

이 동적 로딩을 담당하는 부분이 바로 클래스 로더 이다.



### Exceution Engine

> 바이트 코드들을 하나의 명령 단위로 읽어 컴퓨터가 이해할 수 있는 기계어로 번역하고 명령을 수행

위의 클래스 로더에 의해 메모리 영역 (Runtime Data Areas) 에 적재된 바이트 코드 들을 하나의 명령 단위로 읽어서 컴퓨터가 이해할 수 있는 기계어로 변역하고 명령을 수행한다.

이 과정을 수행하는 방식으로 `Interpreter` 방식과 `JIT` (Just-In-Time) 방식이 존재한다.



### Runtime Data Areas



JVM이 운영체제 위에서 실행되면서 적재된 프로그램이 요구하는 만큼 메모리를 할당받으면, 이 메모리를 아래 5가지 영역으로 나누어 관리한다.



#### PC Register

현재 쓰레드가 다음으로 어떤 명령을 수행해야 할지 기록하는 부분 (JVM 명령의 주소를 가짐)

#### JVM Stack

지역변수, 메소드의 매개변수, 메소드 정보, 임시 데이터 등을 저장하는 부분

#### Native Method Stack

자바 이외 다른 언어에서 작성된 네이티브 코드를 수행하기 위한 메모리 영역

컴파일되어 생성되는 바이트 코드를 해석해서 실행하는 것이 아닌, 실제 당장 수행할 수 있는 기계어로 작성된 네이티브 프로그램을 실행시키는 영역이다.

#### Heap

런타임 시 동적으로 할당되는 데이터가 저장되는 영역 (생성된 객체, 배열 등)

​	-> Heap에 할당된 데이터들은 Garbage Collection의 대상이기 때문에 JVM 성능 이슈에서 가장 많이 언급되는 영역이다.

#### Method Area

JVM이 시작, 생성되고, JVM이 읽은 각각의 클래스, 인터페이스에 대한 멤버 변수 및 생성자를 포함한 메소드 코드, 정적 변수, 상수, 메소드의 바이트 코드 등을 보관하는 부분이다.

한 번 로드된 후 메모리에 항상 사주하고 있는 영역이기 때문에, 모든 쓰레드가 공유 가능하다.



### Garbage Colletion

참조되지 않은객체 탐색 후 삭제하고

삭제된 객체의 메모리를 반환 후 힙 메모리 재사용한다.



## JVM 프로그램 실행 흐름

1. JVM 기반 프로그램이 실행 시, JVM은 OS 로부터 해당 프로그램이 요구하는 만큼 메모리를 할당 받는다. 할당받은 메모리를 용도에 따라 여러 영역 (Runtime Data Areas)으로 나누어 관리하게 된다.
2. Java 컴파일러 (javac) 가 자바 소스코드를 읽고, 이를 바이트 코드(`.class`)로 변환 시킨다.
3. 변환된 바이트 코드 파일들을 클래스 로더를 통해 JVM 메모리 영역으로 로딩한다.
4. 로딩된 바이트 코드 파일들은 Execution Engine 을 통해 해석된다.
5. 해석된 바이트 코드는 메모리 영역에 배치되어 실질적인 동작 수행이 이루어진다. 이 동작 수행 과정 속에서 JVM 은 필요에 따라 쓰레드 동기화, Garbage Colletion 같은 메모리 작업을 수행한다.





---

Velog : https://velog.io/@haero_kim/JVM-%EC%9D%B4-%EB%AD%90%EB%83%90%EA%B3%A0-%EB%AC%BC%EC%9C%BC%EC%8B%A0%EB%8B%A4%EB%A9%B4