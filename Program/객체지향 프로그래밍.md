# 객체지향 프로그래밍

> 어떤 개념에 대한 자료형과 함수를 '객체' 형태로 묶어 관리하기
>
> 개념에 대한 모든 물리적, 논리적 요소를 객체로 만드는 것이 객체지향 프로그래밍

객체지향 프로그래밍에 대한 이해가 쉽지 않다.

객체지향을 외우기 보단 등장 배경부터 알고 왜 등장 했는지 알 필요가 있다.



## 순차적 프로그래밍 (비구조적)

> 정의한 기능의 흐름에 따라 순서대로 동작을 추가하며 프로그램을 완성하는 방식
>
> 직관적이나 규모가 커지면 코드가 너무 복잡해져 기능을 모듈화 할 수 있는 절차적 프로그래밍 등장

간단한 프로그램의 경우, 이렇게 코드를 짜게 되면 흐름이 눈으로 보이기 때문에 매우 직관적이다.

그러나, 프로그램 규모가 커진다면 예를 들어, A -> B -> C 로 구현되다가 C에서 A로 돌아가야 할 상황이라면 `goto` 를 활용한다.

`goto` 문을 활용하게 된다면 스파게티 코드가 되고 나열된 코드 속에서 위로 아래로 갔다 왔다를 반복한다.

그렇게 되면 동작이 직관적이지 못하고, 장점이 사라진다.



그래서 등장 한 것이 절자적, 구조적 프로그래밍 이다.



## 절차적 프로그래밍 (구조적)

> 반복되는 동작을 함수 및 프로시저 형태로 모듈화하여 사용하는 방식
>
> 자료형와 함수를 연관 지어서 따로 관리 할 수 없기 떄문에 객체지향 등장

절차적 프로그래밍 에서 '절차' 는 함수를 의미한다.

프로시저 : 리턴값이 없는 함수



반복 동작을 모듈화하여 코드를 많이 줄일 수 있다. 하지만 프로시저 라는 것 자체가 추상적이라는 단점이 있다.

Ex) 도서관의 도서 관리 프로그램 개발

- '책' 이라는 자료형 구현
- 책에 대한 함수 구현

구조적 프로그래밍에서는 이 둘을 따로 생각할 수 밖에 없다.

책은 책, 책에 관한 함수는 따로 있기에, 같은 소스코드 파일 내에 있더라도 이 둘의 연관 여부를 알 수 없다.

논리적으로 묶여 있을 수 없는 구조이기 때문에 동작이 추상적인 것이다.



따라서, 이를 묶기 위한 패러다임으로 '객체지향 프로그래밍' 이 등장한다.



## 객체지향 프로그래밍

> 어떤 개념에 대한 자료형과 함수를 '객체' 형태로 묶어 관리하기
>
> 개념에 대한 모든 물리적, 논리적 요소를 객체로 만드는 것이 객체지향 프로그래밍

어떤 개념에 대한 자료형과 함수를 '객체' 형태로 함께 묶어서 관리하기 위해 객체지향 프로그래밍 패러다임이 등장한다.

핵심 포인트는 객체 내부에 자료형 필드와 함수가 함께 존재하는 것이다.

가능한 모든 물리적, 논리적 요소를 객체로 만드는 것이 객체지향 프로그래밍이다.



Ex) 위의 예시 도서관의 도서 관리 프로그램 개발

책의 제목, 저자, 페이지수 와 같은 필드와

대출하기, 반납하기 등의 메소드를 책이라는 객체에 몽땅 묶어서 관리하는 것이 가능해진다.

이렇게 되면, 추상적이었던 동작도 훨씬 직관적으로 보이게 되어 코드 가독성이 증가한다.



결론적으로 객체 간의 독립성이 생기고, 중복되는 코드의 양이 줄어들고, 유지보수에 용이 해진다.

![img](https://media.vlpt.us/images/haero_kim/post/bb2b6f34-c731-40ba-ba49-04bf22f996cc/good%20phopho%20of%20OOP.png)



### 객체지향 프로그래밍 4가지 특징



#### 추상화 (Abstraction)

> 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념
>
> 객체들이 공통적으로 필요로 하는 속성이나 동작을 하나로 추출해내는 작업



세상에 있는 어떤 개념을 클래스로 만들고, 그 클래스의 상태와 행동을 부여한 객체를 만든다.

그러나 세상에 모든 것을 다 클래스에 담고 객체를 만드는 것은 불가능하다.

그래서 추상적으로 생각해 일단 큰 틀의 클래스를 구현하고 거기에 최소 이러한 공통적인 요소나 필수적인 요소는 들어갔으면 하는 바램에서 만든 것이 `추상클래스` 이다.



ex) `람보르기니, 페라리, 맥라렌, 롤스로이스` 고가의 차량이라는 공통점

고가의 차량의 공통적인 특징(비쌈, 배기음, 제로백 등)을 만들어 활용하면된다.

여기에 `부가티` 를 추가될 수 있는데, 이 때 추상화로 구현해두면 다른 코드는 건드리지 않고 추라고 만들 부분만 새로 만들어주면 된다.



#### 캡슐화 (Encapsulation)

> 하나의 객체에 대해 그 객체가 특정한 목적을 위하여 필요한 변수나 메소드를 하나로 묶는 것
>
> 클래스에서 만들어진 객체가 특정한 목적을 잘 수행할 수 있도록 사용할 변수와 메서드를 관련성 있게 클래스에 구성
>
> 캡슐화 하는 중요한 목적 중 정보은닉

정보은닉 : 객체정보를 쉽게 접근하지 못하게 접근제한 하는 것 (데이터보호)



정보 은닉화를 통해 높은 응집도, 낮은 결합도를 유지 할 수 있도록 설계하는 것

한 곳에서 변화가 일어나도 다른 곳에 미치는 사이드 이펙트를 최소화 시키는 것을 의미한다.

즉, 객체 내부의 어떤 동작에 대한 구현이 어떻게 되어 있는지 감추는 것이다.

이를 통해 외부에서 뭔가 잘못 건드려 객체를 손상시키는 일을 방지 할 수 있다.



결합도란 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인지를 나타내는 지표이다.

객체 간의 독립성을 강조하기 위해 객체 지향 프로그래밍이 등장했는데, 결합도가 높으면 객체지향으로 설계하는 의미는 없다.

따라서 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만드는 것이 중요하다.

소프트웨어 공학적으로 좋은 설계는

**객체 내의 모듈 간의 요소가 밀접한 관련이 있는 것으로 구성하여**

**응집도를 높이고, 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계이다.**

> 객체 각각은 독립적으로 작용 할 수 있도록 응집도는 강하고, 다른 모듈을 참조하는 결합도는 낮아야 한다.

높은 응집도, 낮은 결합도는 '은닉화'를 통해 이룰 수 있다.

외부에서 접근할 필요 없는 것들은 접근 제한자를 지정하여 제한 두는 것이다. (`private`, `public` 등)

외부 객체는 객체 내부의 구조를 모르게 하고, 해당 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 잇도록 하여 의도하지 않은 동작 오류를 방지하고 유지보수 효율을 높일 수 있다.



#### 상속 (Inheritance)

> 기존 상위클래스에 근거하여 새롭게 클래스와 행위를 정의할 수 있게 도와주는 개념
>
> 기존 클래스에 기능을 가져와 재사용할 수 있으면서 동시에 새롭게 만든 클래스에 새로운 기능을 추가



상속이 필요한 이유는 코드의 중복을 없애기 위함이다.



#### 다형성 (Polymorphism)

> 서로 다른 클래스의 객체가 같은 동작 수행 명령을 받았을 때, 각자의 특성에 맞는 방식으로 동작하는 것
>
> 형태가 같은 데 다른 기능을 하는 것을 의미
>
> 상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해준다.



##### Overriding & Overloading

- Overriding (오버라이딩)

  부모 클래스에서 상속받은 자식 클래스에서 부모클래스에서 만들어진 메서드를 자식 클래스에서 자신의 입맛대로 다시 재정의해서 사용하는 것을 말한다.

- Overloading (오버로딩)

  같은 이름의 메서드를 사용하지만 메서드마다 다른 용도로 사용되며 그 결과물도 다르게 구현할 수 있게 만드는 개념



Ex) 동물 울음 소리

고양이와 사자는 모두 울음 이라는 속성이 추가 되지만 실제 울음소리는 다르다.

이것을 다형성을 통하여 해결할 수 있다.



---

참고사이트

Velog 1 : https://velog.io/@hkoo9329/OOPObject-Oriented-Programming-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%EB%9E%80

Velog 2 : https://velog.io/@haero_kim/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0