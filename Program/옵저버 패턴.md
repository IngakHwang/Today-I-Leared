# 옵저버 패턴

> 어떤 '이벤트'가 일어나는 것을 감시하는 패턴
>
> 이벤트들을 감시하여, 이벤트가 발생할 때 마다 미리 정의해둔 어떠한 동작을 즉각 수행하게 해주는 프로그래밍 패턴
>
> 다른 객체의 상태 변화를 감지하고 이벤트를 발생시키는 패턴

사전적 의미 : Observer - 관측자, 감시자



무언가를 감시하는 역할

프로그래밍에서 Observer패턴이라고 한다면 어떤 '이벤트'가 일어나는 것을 감시하는 패턴을 의미한다.



**안드로이드에서 이벤트가 발생한 순간 예시**

1. 사용자가 키보드를 눌렀을 때
2. 사용자가 어떤 버튼을 터치했을 때
3. 호출한 API의 응답 데이터가 수신됐을 때



아무도 함수로 직접 요청한 적 없지만 시스템에 의해 발생하는 동작들을 이벤트 라고 한다.

이러한 이벤트들을 감시하여, 이벤트가 발생할 때 마다 미리 정의해둔 어떠한 동작을 즉각 수행하게 해주는 프로그래밍 패턴을 옵저버 패턴이라고 한다.



옵저버 패턴을 활용하면 다른 객체의 상태 변화를 별도의 함수 호출 없이 즉각적으로 알 수 있기 때문에,

이벤트에 대한 처리를 자주 해야 하는 프로그램이라면 매우 효율적인 프로그램을 작성 할 수 있다.



## 구현 원리 



예시) 

이벤트를 발생하는 클래스 B, 

B 클래스가 발생하는 이벤트를 수신받고 싶은 클래스 A



**잘못된 예시)**

클래스 A에서 B의 이벤트를 수신받기 위해 클래스 B 인스턴스화 한뒤, B가 자신에게 이벤트가 발생할 때마다 클래스 A가 갖고 있는 메소드 호출

​	-> 치명적 문제 발생

​	-> 클래스 B는 이벤트를 정상적으로 발생하지만, A가 B를 일방적으로 인스턴스화 한 상황이기 때문에, B가 자신을 인스턴스화 한 대상에게 접근할 방법이 없다.	B는 A의 메소드를 호출하지 못한다.

![img](https://media.vlpt.us/images/haero_kim/post/f89d7624-5ee8-4a20-bc2b-d30590e724f1/%E1%84%89%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B32.png)



**올바른 예시) 인터페이스 활용**

![img](https://media.vlpt.us/images/haero_kim/post/4921f863-edd4-4259-a74a-8908113ee30a/%E1%84%89%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B33.png)

둘 사이에 인터페이스를 하나 끼워넣는 방식이다.

A 는 인터페이스를 상속하여 이벤트가 발생할 때마다 실행되게 할 메소드를 구현

B 를 생성할 때 인터페이스 구현체를 전달하여, 이벤트가 발생할 때마다 생성자로 전달받은 A가 구현한 인터페이스 메소드를 호출



- 이 때, 이 인터페이스를 Observer(옵저버) 라고 부른다. 코틀린에서는 Listener 라는 용어를 사용
- B가 구현된 인터페이스 메소드를 호출함으로써 이벤트를 전달하는 행위를 Callback(콜백) 이라고 한다.



## 구현 예시

예시) 

1~100 까지 하나씩 세면서 5의 배수를 만날 때 마다 이벤트 발생

5의 배수 이벤트를 관찰 하고 있다가 이벤트가 수신될 때 마다 5의 배수 출력



### 리스너 인터페이스 만들기

이벤트를 수신받는 객체

이벤트를 발생하는 객체를 이어줄 리스너

```kotlin
//이 인터페이스를 상속받아, 이벤트가 발생 시 마다 호출할 메소드를 구현
interface EventListener{
  fun onEvent(count: Int)
}
```

> 이벤트를 수신해서 출력하는, 인터페이스 구현체



### 이벤트 발생 클래스

생성자로 '리스너'를 받게 된다.

이벤트 발생 시 마다 전달받은 리스너의 메소드를 호출해준다.

```kotlin
//5의 배수 감지 되면 이벤트 발생
class Counter(var listener: EventListener) {
  fun count(){
    for (i in 1..100){
      if (i % 5 == 0){
        listener.onEvent(i)
      }
    }
  }
}
```

> 숫자를 카운트 하면서 5의 배수가 감지되면 이벤트를 발생시키는 클래스



### 이벤트 수신 클래스

`EventListener` 인터페이스를 상속받아, `onEvent()` 메소드를 구현

이렇게 되면, `start()` 가 호출 되었을 때 자신이 구현한 `EventListener` 구현부가 `Counter()` 의 생성자로 전달되고,

5의 배수가 발생할 때 마다 `print("$count")` 가 실행되어 화면에 5의 배수가 연이어 출력

```kotlin
//이벤트를 수신받았을 때 화면에 5의 배수를 출력하는 EventPrinter
class EventPrinter : EventListener{
  
  override fun onEvent(count : Int){
    print("$count")
  }
  
  fun start(){
    Counter(this).count()
  }
  
}
```

> 위 두 요소를 연결지어줄 옵저버 (리스너)



### 실행

```kotlin
fun main(){
  EventPrinter().start()
}
```



**좀 더 코틀린 스러운 실행**

`EventPrinter` 클래스는 `EventListener` 를 상속받아 구현한다.

코틀린에서 '익명 객체'를 통해, 임시로 `EventListener` 를 상속받아 구현한 객체를 만들어 생성자로 넘겨줄 수 있다.

```kotlin
class EventPrinter{
  fun start() {
    val counter = Counter(object : EventListener {
      override fun onEvent(count: Int){
        print("$count")
      }
    })
    counter.count()
  }
}
```





---

참고 사이트 : https://velog.io/@haero_kim/%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4-%EA%B0%9C%EB%85%90-%EB%96%A0%EB%A8%B9%EC%97%AC%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4